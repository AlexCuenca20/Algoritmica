---
output: pdf_document
---

title: "Algoritmos Greedy"
subtitle: Problema 4 - Recubrimiento de grafos
author: "A. Herrera, A. Moya, I. Sevillano, J.L. Suarez"
date: "`r format(Sys.time(), '%d de %B de %Y')`"
output:
  beamer_presentation:
    colortheme: dolphin
    theme: Berkeley
    highlight: zenburn
    slide_level: 1
    includes:
        in_header:
            mystyles.sty
compress: yes
---

## Introducción

- En esta presentación se proporciona una solución para el ejercicio 4.
- El código, los resultados de las ejecuciones, las gráficas y los pdf asociados se puede encontrar en [GitHub](https://github.com/andreshp/Algoritmica/tree/master/Practica3/Code).

$\centerline{\includegraphics[width=10cm]{./Images/github-octocat.png}}$

# Explicación del problema

## Definición de recubrimiento

Consideremos un grafo no dirigido G = (V,E). Un conjunto U se dice que es un recubrimiento de G si U ⊆ V y cada arista en E incide en, al menos, un vértice o nodo de U ,es decir,

∀(x, y) ∈ E : x ∈ U o y ∈ U

# Explicación del problema

## Definición de recubrimiento minimal

Un conjunto U, recubrimiento de G, se dice minimal si cuenta con el menor número de nodos posibles.

# Explicación del problema

## Partes del ejercicio

En este ejercicio trataremos de encontrar algoritmos greedy que encuentren el recubrimiento minimal de grafos no dirigidos y de grafos que sean árboles. Tras esto, se realizará una comparación de los algoritmos sin ambos grafos fueran árboles.

# Solución teórica

## Imagen sobre la que trabajaremos

$\centerline{\includegraphics[width=10cm]{./Images/tree.png}}$

# Solución teórica

## Solución al problema para éste grafo

$\centerline{\includegraphics[width=10cm]{./Images/tree_optimum.png}}$

# Solución teórica

## Solución al problema para un grafo arbitrario

Tras múltiples intentos que se narrarán a continuación, no conseguimos un algoritmo polinomial óptimo para el problema sobre grafos arbitrarios por lo que pensamos que este en su versión de decisión era NP. De hecho, no solo es NP sino que es NP Completo.

# Solución teórica

## Algoritmos realizados

Es claro que si cogemos U=G es un recubrimiento, pero obviamente podemos encontrar muchos que sean mejores. Vayamos con el primer algoritmo diseñado:

1. U = ∅
2. Para cada arista (x, y) ∈ E tomamos como nodo x o y aleatoriamente y lo añadimos a U.

# Solución teórica

## Algoritmos realizados 

En este caso, añadimos de cada arista uno de los nodos, sin tener en cuenta si ya se añadió antes.

Problema: Es claramente mejorable y quizás podamos encontrar mejores soluciones añadiendo una estrategia greedy al algoritmo

# Solución teórica

## Algoritmos realizados

El segundo algoritmo realizado se basa en el anterior, pero empleando una estrategia greedy. Veamos: 

1. U = ∅
2. Para cada arista (x, y) ∈ E tomamos un nodo v y lo añadimos a U donde v es:
   • x si x ∈ U .
   • y si y ∈ U .
   • Uno de los dos, elegido aleatoriamente, si x, y ∈ U .

En efecto, si algún nodo sobre el que incide la arista ya está en U no tenemos por qué añadir uno nuevo.

# Solución teórica

## Algoritmos realizados

Este algoritmo greedy, lineal sobre el número de aristas y aleatorio no es óptimo como cabe esperar. No es difícil encontrar un ejemplo en el que obtengamos una mala solución:

$\centerline{\includegraphics[width=10cm]{./Images/tree_greedy2.png}}$

# Solución teórica

## Algoritmos realizados

Por último, intentamos plantear un nuevo algoritmo, que sin embargo también nos puede generar malas soluciones (por ejemplo la que acabamos de mostrar). Este algoritmo consiste en lo siguiente:

Tomamos siempre el nodo de G de mayor grado y tras añadirlo a U, eliminamos de V tanto este nodo como las aritas que inciden sobre él. Repetimos el proceso hasta que todas las aristas del grafo incidan sobre los nodos de U.

~~~python
# Pseudocódigo del algoritmo.
# G = (V, E) es el grafo sobre el que se ejecuta el algoritmo.
U = []
while not E.isEmpty:
  v = V.nodeMaximumDegree()
  U.add(v)
  for edge in U:
    E.delete(edge) if edge[0] == v or edge[1] == v
  V.delete(v)
~~~

# Solución teórica

## Solución para un árbol

Proposición 1.
Sea T = (V, E) un árbol. Entonces, existe un recubrimiento minimal del mismo en el cual no contiene a ninguna hoja del árbol pero sí a todo padre de una hoja.

# Solución teórica

## Algoritmo óptimo para árboles

En cada iteración se calculan las hojas del árbol y se añaden los padres al
futuro recubrimiento, siguiendo la filosofía de la proposición 1. Posteriormente se eliminan las hojas, sus padres y las aristas que inciden en estos de T y se repite el proceso.

~~~python
# Pseudocódigo del algoritmo.
# T es el árbol sobre el que se ejecuta el algoritmo.
# Se asume que se ha tomado una raíz para T.
U = []
while not E.isEmpty:
  hojas = T.hojas()
  for hoja in hojas:
    U.append(hoja.parent)
    T.delete([hoja, parent])  
~~~

# Solución teórica

## Algoritmo óptimo para árboles

Es fácil de observar, sobre todo si lo vemos por inducción, que este algoritmo es el óptimo: Para una iteración claramente es el óptimo. Tras esto, si suponemos que es óptimo para N iteraciones, en el caso N+1 añadiríamos "lo que está por encima" y es necesario para obtener el recubrimiento minimal, es lo que vendría a ser añadir los padres de algo que ya sabíamos que era correcto.

# Solución teórica

## Algoritmo óptimo para árboles con recorrido post-orden

Una mejor implementación del algoritmo se puede lograr usando el recorrido en post-orden del árbol:

~~~python
# Si T es el árbol sobre el que se desea aplicar el algoritmo,
# realizar algoritmoOptimo(T.raiz).
# Parámetros: v es un nodo del árbol
def algoritmoOptimo(v):
  U = []
  # Se calcula primero U para el nivel inferior.
  for hijo in v.hijos:
    U = U.union(algoritmoOptimo(hijo))
    # Si algún hijo no está en U, se añade v.
  for hijo in v.hijos:
    if hijo not in U:
      U.append(hijo); break
  return U
~~~

# Solución teórica

## Algoritmo óptimo para árboles con recorrido post-orden

¿Quién termina de dar bien esta explicación?

# Análisis empírico

## Comparaciones

Compararemos ahora el resultado de llevar a cabo varias ejecuciones. Esto falta por hacer aún

# Fin de la presentación

**¡Gracias por su atención!**
