<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Organización de la práctica</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>



<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



</head>

<body>
<p>\( \pagebreak \)</p>

<h1>Organización de la práctica</h1>

<p>Se adjunta el directorio comprimido <strong>Code</strong> con todos los datos obtenidos. La información se organiza como sigue:</p>

<ul>
<li>Los códigos <strong>.cpp</strong> de los distintos algoritmos están disponibles en la carpeta <strong>src</strong>.</li>
<li>En la carpeta <strong>sh</strong> se encuentran scripts auxiliares, cada uno especializado en la toma de datos de uno o varios
algoritmos concretos.</li>
<li>En la carpeta <strong>plot</strong>, de la misma forma, se encuentran scripts especializados en la elaboración de las distintas
gráficas.</li>
<li>El script de bash <strong>ejecuciones.sh</strong> se encarga de obtener todos los datos y gráficas para todos los
algoritmos llamando a los scripts mencionados anteriormente.</li>
<li>En las carpetas <strong>Datos</strong><strong><em>Autor</em></strong> se almacenan los archivos .dat generados por cada uno de los autores,
en sus respectivos PCs. Los ficheros contienen, para cada algoritmo, varias parejas <em>[tamaño tiempo]</em> correspondientes
a distintas ejecuciones del programa con distintos tamaños y sus respectivos resultados.
Han sido generados con <strong>ejecuciones.sh</strong> y son utilizados a lo largo del trabajo.</li>
<li>De forma análoga, están disponibles los directorios <strong>Tablas</strong><strong><em>Autor</em></strong> e <strong>Imagenes</strong><strong><em>Autor</em></strong> que contienen tablas
en formato <strong>.md</strong> con los resultados y las gráficas del comportamiento de los algoritmos generadas por <em>gnuplot</em>,
respectivamente.</li>
</ul>

<p>Cada ejercicio tiene su apartado en el pdf con su corresponiente enunciado y solución.</p>

<!--Los datos y gráficas tomados junto con toda la estructura jerárquica de la práctica pueden consultarse [aquí](https://github.com/andreshp/Algoritmica/tree/master/Practica1/Code).-->

<h1>Ejercicio 1: Cálculo de la eficiencia empírica</h1>

<p><strong>Enunciado:</strong></p>

<p>Calcule la eficiencia empírica de los algoritmos pedidos. Defina adecuadamente los tamaños de entrada para que se generen 
al menos 25 datos. Incluya en la memoria tablas diferentes para los algoritmos de distinto orden de eficiencia (una con los
algoritmos \( O(n^2) \), otra con los \( O(n \log{n}) \), otra con \( O(n^3) \) y otra con \( O((\frac{1+\sqrt{5}}{2})^n) \).</p>

<hr/>

<p>A continuación se proporcionan las tablas, una para cada clase de algoritmos:</p>

<h2>Tabla con los algoritmos cuadráticos</h2>

<table><thead>
<tr>
<th>Tamaño del Vector</th>
<th>Burbuja</th>
<th>Seleccion</th>
<th>Insercion</th>
</tr>
</thead><tbody>
<tr>
<td>1000</td>
<td>0.005971</td>
<td>0.003397</td>
<td>0.001321</td>
</tr>
<tr>
<td>2000</td>
<td>0.018136</td>
<td>0.009589</td>
<td>0.007588</td>
</tr>
<tr>
<td>3000</td>
<td>0.024143</td>
<td>0.014704</td>
<td>0.020282</td>
</tr>
<tr>
<td>4000</td>
<td>0.043267</td>
<td>0.025817</td>
<td>0.023064</td>
</tr>
<tr>
<td>5000</td>
<td>0.067684</td>
<td>0.037817</td>
<td>0.034221</td>
</tr>
<tr>
<td>6000</td>
<td>0.099499</td>
<td>0.055028</td>
<td>0.047872</td>
</tr>
<tr>
<td>7000</td>
<td>0.137072</td>
<td>0.073739</td>
<td>0.064517</td>
</tr>
<tr>
<td>8000</td>
<td>0.181558</td>
<td>0.092111</td>
<td>0.082905</td>
</tr>
<tr>
<td>9000</td>
<td>0.232648</td>
<td>0.118624</td>
<td>0.103043</td>
</tr>
<tr>
<td>10000</td>
<td>0.290489</td>
<td>0.14394</td>
<td>0.124546</td>
</tr>
<tr>
<td>11000</td>
<td>0.354349</td>
<td>0.178614</td>
<td>0.151216</td>
</tr>
<tr>
<td>12000</td>
<td>0.433737</td>
<td>0.20678</td>
<td>0.178228</td>
</tr>
<tr>
<td>13000</td>
<td>0.519202</td>
<td>0.239558</td>
<td>0.209278</td>
</tr>
<tr>
<td>14000</td>
<td>0.59308</td>
<td>0.273397</td>
<td>0.248141</td>
</tr>
<tr>
<td>15000</td>
<td>0.689312</td>
<td>0.314147</td>
<td>0.276967</td>
</tr>
<tr>
<td>16000</td>
<td>0.789129</td>
<td>0.356495</td>
<td>0.317291</td>
</tr>
<tr>
<td>17000</td>
<td>0.890449</td>
<td>0.402106</td>
<td>0.358508</td>
</tr>
<tr>
<td>18000</td>
<td>1.01538</td>
<td>0.450575</td>
<td>0.397242</td>
</tr>
<tr>
<td>19000</td>
<td>1.1313</td>
<td>0.50472</td>
<td>0.435913</td>
</tr>
<tr>
<td>20000</td>
<td>1.26128</td>
<td>0.55525</td>
<td>0.483853</td>
</tr>
<tr>
<td>21000</td>
<td>1.39441</td>
<td>0.611367</td>
<td>0.541654</td>
</tr>
<tr>
<td>22000</td>
<td>1.55788</td>
<td>0.670662</td>
<td>0.600085</td>
</tr>
<tr>
<td>23000</td>
<td>1.68169</td>
<td>0.732809</td>
<td>0.644882</td>
</tr>
<tr>
<td>24000</td>
<td>1.84769</td>
<td>0.800821</td>
<td>0.70273</td>
</tr>
<tr>
<td>25000</td>
<td>1.9893</td>
<td>0.864984</td>
<td>0.762199</td>
</tr>
</tbody></table>

<h2>Tabla con los algoritmos cúbicos</h2>

<table><thead>
<tr>
<th>Nodos del Grafo</th>
<th>Floyd</th>
</tr>
</thead><tbody>
<tr>
<td>32</td>
<td>0.000596</td>
</tr>
<tr>
<td>64</td>
<td>0.004593</td>
</tr>
<tr>
<td>96</td>
<td>0.01017</td>
</tr>
<tr>
<td>128</td>
<td>0.017141</td>
</tr>
<tr>
<td>160</td>
<td>0.035407</td>
</tr>
<tr>
<td>192</td>
<td>0.054113</td>
</tr>
<tr>
<td>224</td>
<td>0.083649</td>
</tr>
<tr>
<td>256</td>
<td>0.116013</td>
</tr>
<tr>
<td>288</td>
<td>0.153556</td>
</tr>
<tr>
<td>320</td>
<td>0.217792</td>
</tr>
<tr>
<td>352</td>
<td>0.280357</td>
</tr>
<tr>
<td>384</td>
<td>0.362685</td>
</tr>
<tr>
<td>416</td>
<td>0.460287</td>
</tr>
<tr>
<td>448</td>
<td>0.581175</td>
</tr>
<tr>
<td>480</td>
<td>0.703839</td>
</tr>
<tr>
<td>512</td>
<td>0.852424</td>
</tr>
<tr>
<td>544</td>
<td>1.02124</td>
</tr>
<tr>
<td>576</td>
<td>1.25977</td>
</tr>
<tr>
<td>608</td>
<td>1.44669</td>
</tr>
<tr>
<td>640</td>
<td>1.68365</td>
</tr>
<tr>
<td>672</td>
<td>1.93344</td>
</tr>
<tr>
<td>704</td>
<td>2.23303</td>
</tr>
<tr>
<td>736</td>
<td>2.54158</td>
</tr>
<tr>
<td>768</td>
<td>2.89293</td>
</tr>
<tr>
<td>800</td>
<td>3.25971</td>
</tr>
</tbody></table>

<h2>Tabla con el algoritmo de Fibonacci (\( O((\frac{1+\sqrt{5}}{2})^n) \))</h2>

<table><thead>
<tr>
<th>Índice</th>
<th>Fibonacci</th>
</tr>
</thead><tbody>
<tr>
<td>15</td>
<td>1.3e-05</td>
</tr>
<tr>
<td>16</td>
<td>2e-05</td>
</tr>
<tr>
<td>17</td>
<td>2.6e-05</td>
</tr>
<tr>
<td>18</td>
<td>4.4e-05</td>
</tr>
<tr>
<td>19</td>
<td>5e-05</td>
</tr>
<tr>
<td>20</td>
<td>0.000114</td>
</tr>
<tr>
<td>21</td>
<td>8.6e-05</td>
</tr>
<tr>
<td>22</td>
<td>0.000154</td>
</tr>
<tr>
<td>23</td>
<td>0.000582</td>
</tr>
<tr>
<td>24</td>
<td>0.00097</td>
</tr>
<tr>
<td>25</td>
<td>0.001314</td>
</tr>
<tr>
<td>26</td>
<td>0.002554</td>
</tr>
<tr>
<td>27</td>
<td>0.002394</td>
</tr>
<tr>
<td>28</td>
<td>0.003356</td>
</tr>
<tr>
<td>29</td>
<td>0.004289</td>
</tr>
<tr>
<td>30</td>
<td>0.007083</td>
</tr>
<tr>
<td>31</td>
<td>0.011583</td>
</tr>
<tr>
<td>32</td>
<td>0.017354</td>
</tr>
<tr>
<td>33</td>
<td>0.029313</td>
</tr>
<tr>
<td>34</td>
<td>0.047371</td>
</tr>
<tr>
<td>35</td>
<td>0.073093</td>
</tr>
<tr>
<td>36</td>
<td>0.127835</td>
</tr>
<tr>
<td>37</td>
<td>0.190808</td>
</tr>
<tr>
<td>38</td>
<td>0.308124</td>
</tr>
<tr>
<td>39</td>
<td>0.498824</td>
</tr>
<tr>
<td>40</td>
<td>0.849934</td>
</tr>
</tbody></table>

<h2>Tabla con el algoritmo de Hanoi (\( O(2^n)) \))</h2>

<table><thead>
<tr>
<th>Num. Discos</th>
<th>Hanoi</th>
</tr>
</thead><tbody>
<tr>
<td>5</td>
<td>1e-06</td>
</tr>
<tr>
<td>6</td>
<td>3e-06</td>
</tr>
<tr>
<td>7</td>
<td>3e-06</td>
</tr>
<tr>
<td>8</td>
<td>6e-06</td>
</tr>
<tr>
<td>9</td>
<td>9e-06</td>
</tr>
<tr>
<td>10</td>
<td>1.3e-05</td>
</tr>
<tr>
<td>11</td>
<td>4.9e-05</td>
</tr>
<tr>
<td>12</td>
<td>7.6e-05</td>
</tr>
<tr>
<td>13</td>
<td>0.00015</td>
</tr>
<tr>
<td>14</td>
<td>0.00019</td>
</tr>
<tr>
<td>15</td>
<td>0.000393</td>
</tr>
<tr>
<td>16</td>
<td>0.000851</td>
</tr>
<tr>
<td>17</td>
<td>0.002302</td>
</tr>
<tr>
<td>18</td>
<td>0.003382</td>
</tr>
<tr>
<td>19</td>
<td>0.009191</td>
</tr>
<tr>
<td>20</td>
<td>0.019015</td>
</tr>
<tr>
<td>21</td>
<td>0.024593</td>
</tr>
<tr>
<td>22</td>
<td>0.041194</td>
</tr>
<tr>
<td>23</td>
<td>0.065421</td>
</tr>
<tr>
<td>24</td>
<td>0.127555</td>
</tr>
<tr>
<td>25</td>
<td>0.246427</td>
</tr>
<tr>
<td>26</td>
<td>0.483075</td>
</tr>
<tr>
<td>27</td>
<td>0.96832</td>
</tr>
<tr>
<td>28</td>
<td>1.9249</td>
</tr>
<tr>
<td>29</td>
<td>3.83247</td>
</tr>
<tr>
<td>30</td>
<td>7.63996</td>
</tr>
</tbody></table>

<h2>Tabla con los algoritmos n log n</h2>

<table><thead>
<tr>
<th>Tamaño del Vector</th>
<th>Mergesort</th>
<th>Quicksort</th>
<th>Heapsort</th>
</tr>
</thead><tbody>
<tr>
<td>40000</td>
<td>0.015087</td>
<td>0.006235</td>
<td>0.008042</td>
</tr>
<tr>
<td>80000</td>
<td>0.02682</td>
<td>0.014736</td>
<td>0.018251</td>
</tr>
<tr>
<td>120000</td>
<td>0.037756</td>
<td>0.02246</td>
<td>0.027588</td>
</tr>
<tr>
<td>160000</td>
<td>0.041266</td>
<td>0.025439</td>
<td>0.043</td>
</tr>
<tr>
<td>200000</td>
<td>0.059359</td>
<td>0.032775</td>
<td>0.048956</td>
</tr>
<tr>
<td>240000</td>
<td>0.057706</td>
<td>0.041055</td>
<td>0.067071</td>
</tr>
<tr>
<td>280000</td>
<td>0.065938</td>
<td>0.045861</td>
<td>0.065239</td>
</tr>
<tr>
<td>320000</td>
<td>0.082393</td>
<td>0.053183</td>
<td>0.072391</td>
</tr>
<tr>
<td>360000</td>
<td>0.093771</td>
<td>0.057395</td>
<td>0.095929</td>
</tr>
<tr>
<td>400000</td>
<td>0.107337</td>
<td>0.063843</td>
<td>0.102829</td>
</tr>
<tr>
<td>440000</td>
<td>0.102685</td>
<td>0.071064</td>
<td>0.104917</td>
</tr>
<tr>
<td>480000</td>
<td>0.122825</td>
<td>0.076521</td>
<td>0.111892</td>
</tr>
<tr>
<td>520000</td>
<td>0.136037</td>
<td>0.082585</td>
<td>0.120963</td>
</tr>
<tr>
<td>560000</td>
<td>0.141045</td>
<td>0.087434</td>
<td>0.132638</td>
</tr>
<tr>
<td>600000</td>
<td>0.150005</td>
<td>0.093448</td>
<td>0.143338</td>
</tr>
<tr>
<td>640000</td>
<td>0.1658</td>
<td>0.100634</td>
<td>0.156171</td>
</tr>
<tr>
<td>680000</td>
<td>0.181068</td>
<td>0.109131</td>
<td>0.165101</td>
</tr>
<tr>
<td>720000</td>
<td>0.211107</td>
<td>0.115456</td>
<td>0.178005</td>
</tr>
<tr>
<td>760000</td>
<td>0.205422</td>
<td>0.121493</td>
<td>0.188856</td>
</tr>
<tr>
<td>800000</td>
<td>0.226734</td>
<td>0.129283</td>
<td>0.193322</td>
</tr>
<tr>
<td>840000</td>
<td>0.200972</td>
<td>0.136155</td>
<td>0.207626</td>
</tr>
<tr>
<td>880000</td>
<td>0.211482</td>
<td>0.141553</td>
<td>0.223124</td>
</tr>
<tr>
<td>920000</td>
<td>0.23571</td>
<td>0.148845</td>
<td>0.229493</td>
</tr>
<tr>
<td>960000</td>
<td>0.240497</td>
<td>0.155352</td>
<td>0.247564</td>
</tr>
<tr>
<td>1000000</td>
<td>0.244299</td>
<td>0.178312</td>
<td>0.267759</td>
</tr>
</tbody></table>

<h2>Tabla con los algoritmos de ordenación</h2>

<p>Finalmente, mostramos una tabla con la comparativa de todos los algoritmos de ordenación, tanto cuadráticos como \( n \log{n} \).
Podemos apreciar que para tamaños relativamente pequeños (25.000) ya existen notables diferencias:</p>

<table><thead>
<tr>
<th>Tamaño del Vector</th>
<th>Burbuja</th>
<th>Seleccion</th>
<th>Insercion</th>
<th>Mergesort</th>
<th>Quicksort</th>
<th>Heapsort</th>
</tr>
</thead><tbody>
<tr>
<td>1000</td>
<td>0.005971</td>
<td>0.003397</td>
<td>0.001321</td>
<td>0.000359</td>
<td>0.000195</td>
<td>0.000114</td>
</tr>
<tr>
<td>2000</td>
<td>0.018136</td>
<td>0.009589</td>
<td>0.007588</td>
<td>0.000756</td>
<td>0.000269</td>
<td>0.000639</td>
</tr>
<tr>
<td>3000</td>
<td>0.024143</td>
<td>0.014704</td>
<td>0.020282</td>
<td>0.00074</td>
<td>0.000671</td>
<td>0.001008</td>
</tr>
<tr>
<td>4000</td>
<td>0.043267</td>
<td>0.025817</td>
<td>0.023064</td>
<td>0.000748</td>
<td>0.00067</td>
<td>0.001327</td>
</tr>
<tr>
<td>5000</td>
<td>0.067684</td>
<td>0.037817</td>
<td>0.034221</td>
<td>0.002255</td>
<td>0.000567</td>
<td>0.000822</td>
</tr>
<tr>
<td>6000</td>
<td>0.099499</td>
<td>0.055028</td>
<td>0.047872</td>
<td>0.001549</td>
<td>0.001661</td>
<td>0.001141</td>
</tr>
<tr>
<td>7000</td>
<td>0.137072</td>
<td>0.073739</td>
<td>0.064517</td>
<td>0.003041</td>
<td>0.001953</td>
<td>0.001359</td>
</tr>
<tr>
<td>8000</td>
<td>0.181558</td>
<td>0.092111</td>
<td>0.082905</td>
<td>0.003166</td>
<td>0.002456</td>
<td>0.001679</td>
</tr>
<tr>
<td>9000</td>
<td>0.232648</td>
<td>0.118624</td>
<td>0.103043</td>
<td>0.004058</td>
<td>0.001649</td>
<td>0.002775</td>
</tr>
<tr>
<td>10000</td>
<td>0.290489</td>
<td>0.14394</td>
<td>0.124546</td>
<td>0.003803</td>
<td>0.001971</td>
<td>0.002436</td>
</tr>
<tr>
<td>11000</td>
<td>0.354349</td>
<td>0.178614</td>
<td>0.151216</td>
<td>0.004144</td>
<td>0.002048</td>
<td>0.003717</td>
</tr>
<tr>
<td>12000</td>
<td>0.433737</td>
<td>0.20678</td>
<td>0.178228</td>
<td>0.0041</td>
<td>0.003616</td>
<td>0.004062</td>
</tr>
<tr>
<td>13000</td>
<td>0.519202</td>
<td>0.239558</td>
<td>0.209278</td>
<td>0.005279</td>
<td>0.003037</td>
<td>0.004538</td>
</tr>
<tr>
<td>14000</td>
<td>0.59308</td>
<td>0.273397</td>
<td>0.248141</td>
<td>0.006677</td>
<td>0.002399</td>
<td>0.003738</td>
</tr>
<tr>
<td>15000</td>
<td>0.689312</td>
<td>0.314147</td>
<td>0.276967</td>
<td>0.006024</td>
<td>0.002247</td>
<td>0.006105</td>
</tr>
<tr>
<td>16000</td>
<td>0.789129</td>
<td>0.356495</td>
<td>0.317291</td>
<td>0.007461</td>
<td>0.002721</td>
<td>0.003677</td>
</tr>
<tr>
<td>17000</td>
<td>0.890449</td>
<td>0.402106</td>
<td>0.358508</td>
<td>0.006324</td>
<td>0.002745</td>
<td>0.00402</td>
</tr>
<tr>
<td>18000</td>
<td>1.01538</td>
<td>0.450575</td>
<td>0.397242</td>
<td>0.008806</td>
<td>0.005765</td>
<td>0.00688</td>
</tr>
<tr>
<td>19000</td>
<td>1.1313</td>
<td>0.50472</td>
<td>0.435913</td>
<td>0.008887</td>
<td>0.004034</td>
<td>0.003986</td>
</tr>
<tr>
<td>20000</td>
<td>1.26128</td>
<td>0.55525</td>
<td>0.483853</td>
<td>0.007868</td>
<td>0.003407</td>
<td>0.007215</td>
</tr>
<tr>
<td>21000</td>
<td>1.39441</td>
<td>0.611367</td>
<td>0.541654</td>
<td>0.00544</td>
<td>0.00359</td>
<td>0.007316</td>
</tr>
<tr>
<td>22000</td>
<td>1.55788</td>
<td>0.670662</td>
<td>0.600085</td>
<td>0.006238</td>
<td>0.00374</td>
<td>0.008641</td>
</tr>
<tr>
<td>23000</td>
<td>1.68169</td>
<td>0.732809</td>
<td>0.644882</td>
<td>0.010339</td>
<td>0.006076</td>
<td>0.008602</td>
</tr>
<tr>
<td>24000</td>
<td>1.84769</td>
<td>0.800821</td>
<td>0.70273</td>
<td>0.010512</td>
<td>0.006921</td>
<td>0.009229</td>
</tr>
<tr>
<td>25000</td>
<td>1.9893</td>
<td>0.864984</td>
<td>0.762199</td>
<td>0.009398</td>
<td>0.003104</td>
<td>0.006293</td>
</tr>
</tbody></table>

<p>\( \pagebreak \)</p>

<h1>Ejercicio 2: Elaboración de gráficas</h1>

<p><strong>Enunciado:</strong></p>

<p>Con cada una de las tablas anteriores genere un gráfico comparando los tiempos de los algoritmos. Indique claramente el significado de cada serie. Para los algoritmos que realizan la misma tarea (los de ordenación), incluya también una gráfica con todos ellos, para poder apreciar las diferencias de rendimiento de algoritmos con diferente orden de eficiencia.</p>

<hr/>

<p>No se debe pasar por alto que los datos utilizados en los algoritmos de ordenación y el de Floyd se generan de manera aleatoria. Esto influye sobre todo al comparar los algoritmos de ordenación entre sí pues es bien conocido que ciertos algoritmos operan bien cuando los datos están casi ordenados (insección, burbuja) y otros no (quicksort). Existen otros algoritmos que el tiempo dedicado es casi independiente de los datos de entrada (selección, mergesort, heapsort). Sin embargo, el error que se pueda cometer por este hecho es pequeño ya que es muy raro obtener datos casi ordenados de forma aleatoria.</p>

<h2>Gráfica comparativa de los algoritmos cuadráticos.</h2>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesAndres/cuadraticos.png}} \)</p>

<p>Cabe destacar, que dentro de los algoritmos cuadráticos también existen ciertas diferencias; a continuación, vamos a razonar su existencia. Como se puede observar, el algoritmo de la burbuja emplea un mayor tiempo que los otros dos. Le sigue el algoritmo de selección y de cerca el de inserción. La razón es la siguiente:</p>

<ul>
<li>Comparaciones e intercambios del algoritmo de selección: \( \frac{n(n-1)}{2} \) y \( n \) respectivamente.</li>
<li>Comparaciones e intercambios del algoritmo de burbuja: \( \frac{n(n-1)}{2} \) y un intercambio por cada par de índices \( i < j \) tales que \( v[i] > v[j] \).</li>
<li>Comparaciones e intercambios del algoritmo de inserción: \( \frac{n(n-1)}{4} \) en promedio y \( n \) desplazamientos de los datos (uno por iteración) luego \( \frac{n(n-1)}{4} \) asignaciones en promedio.</li>
</ul>

<p>El número de intercambios del algoritmo burbuja suele ser mucho mayor en promedio que en el caso del algoritmo de selección, que siempre es \( n \). Los intercambios son una operación relativamente costosa, lo que produce el mayor tiempo dedicado.</p>

<p>Veamos ahora, por qué el de insercción es el mejor de los tres. El algoritmo de insercción, en su peor caso (vector totalmente invertido)  utiliza el mismo número de comparaciones que el de selección y en el caso promedio la mitad. Esto produce un ahorro importante de tiempo que prevalece en el total del algoritmo (los desplazamientos no son tan costosos). Al ser mejor que el de selección ya es mejor automáticamente que el algoritmo de burbuja.</p>

<h2>Gráfica del algoritmo cúbico (Floyd)</h2>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesAndres/cubicos.png}} \)</p>

<p>Contrastando con las gráficas anteriores, podemos ver que existe una gran diferencia entre los algoritmos cuadráticos y el algoritmo de Floyd, que es cúbico (éste último emplea un tiempo mucho mayor).</p>

<p>Como nota, el algoritmo de Dijkistra resuelve el mismo problema para grafos con pesos no negativos y consigue una eficiencia de \( O(n^2 \log n) \), por lo que es mucho más práctico dada la diferencia que existe entre ambos órdenes de eficiencia.</p>

<h2>Gráfica del algoritmo de Fibonacci (\( O((\frac{1+\sqrt{5}}{2})^n) \))</h2>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesAndres/fibonacci.png}} \)</p>

<p>Tanto en éste algoritmo como en el de Hanoi podemos ver la naturaleza exponencial de la curva. ¡A partir de un <em>n</em> pequeño el tiempo ya es de segundos! Por ello se han utilizado datos pequeños en las ejecuciones. Como curiosidad, para <em>n</em> = 50 ya no terminaba en un tiempo razonable.</p>

<h2>Gráfica del algoritmo de Hanoi (\( O(2^n) \))</h2>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesAndres/hanoi.png}} \)</p>

<p>La naturaleza exponencial de este algoritmo es más drástica, tardando más de 7 segundos solo para <em>n</em> = 30. ¡Para <em>n</em> = 40 tardaría dos días!</p>

<h2>Gráfica de los algoritmos \( O(n \log{n}) \)</h2>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesAndres/nlogn.png}} \)</p>

<p>El algoritmo quicksort es claramente más rápido. Este algoritmo es de naturaleza aleatoria, así que el hecho de que los vectores se generen aleatoriamente influye en su correcto funcionamiento. Nótese que si los vectores estuviesen casi ordenados quicksort sería cuadrático. Sin embargo, esto es muy difícil que pase con vectores aleatorios.</p>

<p>El peor funcionamiento de mergesort se produce ya que utiliza espacio extra en la operación de <em>merge</em>, que suele ser además bastante más lenta que el particionamiento del quicksort.</p>

<p>En el caso del heapsort, este algoritmo en primer lugar crea el heap y luego lo ordena extrayendo el mínimo cada vez. El tener que realizar ambas operaciones hace que su constante sea casi el doble que la de quicksort que empieza a ordenar desde el primer momento.</p>

<p>Mergesort y heapsort operan con similar velocidad. Sin embargo, es preferible el último puesto que no utiliza memoria exta, es <em>in-place</em>.</p>

<h2>Gráfica comparativa con todos los algoritmos de ordenación.</h2>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesAndres/ordenacion.png}} \)</p>

<p>Por último y a modo de conclusión, podemos observar esta gráfica en la que quedan comparados los algoritmos cuadráticos y los de orden \( n \log(n) \). No se compara con el resto de algoritmo por la abismal diferencia existente, hecho mostrado anteriormente. Esta diferencia es aún mayor en el caso de los exponenciales que son inviables en la práctica. </p>

<p>En cuánto a lo que vemos en esta gráfica, podemos observar la gran diferencia entre los algoritmos quicksor, mergesort y heapsort y los cuadráticos. Podemos ver también que dentro de este conjunto de algoritmos, como hemos explicado anteriormente, el peor de todos es el de la burbuja.</p>

<p>\( \pagebreak \)</p>

<h1>Ejercicio 3: Eficiencia híbrida.</h1>

<p><strong>Enunciado:</strong></p>

<p>Calcule la eficiencia híbrida de los algoritmos. Pruebe también con otros ajustes que no se correspondan con la eficiencia teórica y compruebe la variación en la calidad del ajuste.</p>

<hr/>

<h2>Ajustes de los algoritmos de ordenación cuadráticos:</h2>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesOptAndres/cuadraticos_ajuste.png}} \)</p>

<p>En esta gráfica podemos observar la gráfica a la que se ajusta el comportamiento de cada uno de estos algoritmos y podemos observar cómo la constante oculta (a0) es de más del doble (de hecho, casi el triple) en el caso del algoritmo de la burbuja que en el caso del de selección (y lo mismo ocurre respecto al de insercción). También podemos ver que el algoritmo de selección y de insercción tienen un comportamiento muy similar. </p>

<p>Con todo esto, lo que queda en evidencia es que, como ya presagiamos en los ejercicios 1 y 2, el algoritmo de la burbuja es el más lento de los 3. La explicación, ya dada en el ejercicio anterior pero que nunca viene mal recordar, es que a pesar de que los algoritmos recorren el mismo número de veces el vector, el número de intercambios es mayor en el caso del algoritmo de burbuja.</p>

<h2>Ajuste del algoritmo de Floyd:</h2>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesOptAndres/cubicos_ajuste.png}} \)</p>

<p>En este caso, podemos ver de nuevo que el comportamiento del algoritmo se ajusta bastante bien al comportamiento de esa función. De nuevo, al igual que anteriormente, queda bastante claro que este algoritmo, que es de orden cúbico, emplea tiempos mucho mayores que los algoritmos cuadráticos.</p>

<h2>Ajuste del algoritmo de Fibonacci:</h2>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesOptAndres/fibonacci_ajuste.png}} \)</p>

<p>En este caso, podemos ver de nuevo que el comportamiento del algoritmo se ajusta bastante bien con el de esta función. Cabe destacar que, tanto en casos cuadráticos, cúbicos como exponenciales, el ajuste se realiza bastante bien, cosa que no ocurre exactamente con los nlogn como veremos más adelante. El motivo es que las operaciones tardan tan poco tiempo que el propio Sistema Operativo genera bastante variación en las medidas. Además, existen otros condicionantes, en el caso de los nlog que se explicarán en el apartado de ajuste de éstos útlimos.</p>

<h2>Ajuste del algoritmo de las torres de Hanoi:</h2>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesOptAndres/hanoi_ajuste.png}} \)</p>

<p>En este caso, de nuevo, podemos ver que este algoritmos se ajusta bastante bien a la función que se observa en la gráfica. En este apartado, cabe destacar que se ve claramente, que pese a ser el algoritmo de las torres de Hanoi y el de Fibonacci ambos exponenciales, se ve que el de Fibonacci es más rápido que el de las torres de Hanoi (1.6 vs 2).</p>

<h2>Ajuste de los algoritmos de ordenación \( O(n\log{n}) \)</h2>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesOptAndres/nlogn_ajuste.png}} \)</p>

<p>Para comenzar, comentar que se ve de nuevo, al igual que comentamos anteriormente, que el mergesort y el heapsort son bastante similares, mientras que el quicksort es el más rápido de los tres. Ésto, como ya explicamos antes en el ejercicio 2, se debe pricipalmente a las reservas de memoria extra que se realizan en los distintos métodos (menor en el quicksort) y el ahorro o consumo de trabajo que supone esta reserva. Ahora, lo explicado queda de manifiesto al observar el ajuste de cada una de estas gráficas, viéndose que el algoritmo mergesort es el más lento, seguido de cerca por el heapsort; mientras tanto, el quicksort es el más rápido (como muestran las constantes ocultas, en torno a 1&#39;5 veces más rápido que los anteriores).</p>

<p>Por otra parte, es necesario comentar a que se debe que el ajuste sea menos preciso que en casos anteriores y que, además, sea distinto para los 3 casos. 
Por un lado, como ya explicamos anteriormente, el hecho de que se tarde menos tiempo en realizar estos algoritmos hace que existan ciertas variaciones en las medidas. 
Por otro lado, podemos ver que el ajuste en el caso del mergesort es peor que en el caso del resto. Ésto se debe a las variaciones que hay en la medida, debido a que, en función del tamaño del vector, se realizan unas particiones distintas(en el caso del mergesort). Podemos observar también que el ajuste es algo mejor en el heapsort que en el quicksort, y ésto se puede deber a la aleatoriedad de éste último.</p>

<h2>Comparativa de ajustes de todos los algoritmos de ordenación</h2>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesOptAndres/ordenacion_ajuste.png}} \)</p>

<p>Con esta última comparativa, queda de manifiesto todo lo dicho anteriormente comparando las gráficas de los algoritmos del mismo orden, mientras que se observa también, que los algoritmos cuadráticos son más lentos que los de orden nlogn.</p>

<h2>Probando otros ajustes</h2>

<p>Finalmente, vamos a probar a realizar otros ajustes sobre ciertos algoritmos, para ver la calidad de estos en comparación con el ajuste teórico, que es el que se ha establecido anteriormente. Por un lado, vamos a intentar ajustar el quicksort, representante de \( O(n\log{n}) \) con ajustes lineales, para observar qué influencia tiene la parte logarítmica del \( n\log{n} \). Por otra parte, intentaremos realizar un ajuste polinomial de un algoritmo exponencial, como es el de Fibonacci.</p>

<h3>Ajuste lineal del quicksort:</h3>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesComparacion/comparacion_ajustes_nlogn.png}} \)</p>

<p>En esta comparativa, podemos observar que el algoritmo quicksort, en la práctica se ajusta a una función lineal con una alta constante. Al final asintóticamente el nlogn es algo más alto, pero para nuestros datos se ajusta bastante bien con la función lineal nombrada anteriormente.</p>

<h3>Ajuste polinomial de un algoritmo exponencial (Fibonacci):</h3>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesComparacion/comparacion_ajustes_fibonacci.png}} \)</p>

<p>En este caso, podemos observar que hasta una longitud de algo más de 35 elementos, el comportamiento es mejor para este algoritmo que para los algoritmos cuadráticos y cúbicos, pero a partir de ahí, crece mucho más rápida que las anteriores. De esta forma queda de manifiesto que su comportamiento no se ajusta al de éstas funciones polinómicas.</p>

<p>\( \pagebreak \)</p>

<h1>Ejercicio 4: estudio de la eficiencia empírica en función de parámetros externos.</h1>

<p><strong>Enunciado:</strong></p>

<p>Otro aspecto interesante a analizar mediante este tipo de estudio es la variación de la eficiencia empírica en función de parámetros externos tales como: las opciones de compilación utilizadas, el ordenador donde se realizan las pruebas, el sistema operativo, etc. Sugiera algún estudio de este tipo, consulte con el profesor de prácticas y llévelo a acabo.</p>

<hr/>

<h2>Comparación de ejecuciones con y sin optimización</h2>

<p>A continuación se muestran las comparaciones de los algoritmos dados para distintos niveles de optimización: sin optimización, y con la optimización <em>O2</em> proporcionada por el compilador de <em>g++</em>.</p>

<h3>Optimización de los algoritmos cuadráticos</h3>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesOptAndres/cuadraticos_con_sin_opt.png}} \)</p>

<p>Para comenzar, podemos ver que los algoritmos, como es lógico, requieren menor tiempo de ejecución que los casos sin optimización. A pesar de ello, es bueno recordar que para esta comparación con la ejecución con optimización depende de varios factores, como: la caché del ordenador y los datos que ésta pueda almacenar, el nivel de optimización del compilador del ordenador desde el que se realiza el ordenador, etc.</p>

<p>Por otra parte, podemos ver que el algoritmo de burbuja, en este caso, incluso optimizado es peor que el resto. Esto se debe a que la optimización no consigue suficiente mejora, no consigue introducir los suficientes datos en caché ni disminuir lo suficiente el código como para que la optimización sea mejor de lo que es. Por este motivo, siguiendo estos factores, el algoritmo de inserción optimizado sigue siendo mejor que el de selección.
Con todo ello, es claro que a pesar de las mejoras en tiempo, el algoritmo sigue siendo de orden cuadrático.</p>

<h3>Optimización del algoritmo de Floyd:</h3>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesOptAndres/cubicos_con_sin_opt.png}} \)</p>

<p>En este caso, podemos ver como la optimización reduce mucho el tiempo de ejcución. Comparando para un cierto tamaño, podemos ver como para un tamaño de 800 nodos del grafo, sin optimización se requieren más de tres segundos mientras que, con optimización, se requiere menos de un segundo. A pesar de todo, el algoritmo sigue siendo de orden cúbico.</p>

<h3>Optimización del algoritmo de Fibonacci:</h3>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesOptAndres/fibonacci_con_sin_opt.png}} \)</p>

<p>En el algoritmo de Fibonacci, a la &ldquo;larga&rdquo; (entre comillas, pues como ya vimos, al tratarse de un algoritmo de orden exponencial no se pueden calculas elementos muy elevados de la sucesión, pues de lo contrario el tiempo sería muy exagerado), la optimización también mejora bastante el algoritmo, pasando de necesitar más de 0.8 segundos para calcular el elemento 40, a necesitar menos de 0.6. Sin embargo, cabe destacar que el algoritmo sigue siendo exponencial, simplemente se consigue una mejora de las constantes ocultas.</p>

<h3>Optimización del algoritmo de las torres de Hanoi:</h3>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesOptAndres/hanoi_con_sin_opt.png}} \)</p>

<p>Al igual que en el caso anterior, el algoritmo de las torres de Hanoi, solo nota la optimización a partir de un determinado valor (en este caso, la diferencia empieza a notarse a partir de 25 discos), de tal forma que el tiempo también se mejora bastante. Un claro ejemplo es que para 30 discos, sin optimizar se necesitaron más de 7 segundos, mientras que con optimización se han necesitado menos de 5. También, como ocurría antes, la optimización supone una mejora, pero el orden del algoritmo sigue siendo exponencial.</p>

<h3>Optimización de los algoritmos de ordenación \( O(n\log{n}) \)</h3>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesOptAndres/nlogn_con_sin_opt.png}} \)</p>

<p>En este último caso (recordemos que hablamos para el caso de las ejecuciones en el ordenador de Andrés, que en otro ordenador por los factores nombrados anteriormente, los resultados podrían ser distintos), y a diferencia de lo que ocurría anteriormente en el caso de los algoritmos cuadráticos, los tres algoritmos optimizados son más rápidos que el mejor de ellos sin optimizar (quicksort). </p>

<p>También, podemos ver como el comportamiento sigue siendo similar al comparar las tres funciones: mergesort y heapsort muy similares mientras que el quicksort algo más rápido. Los motivos siguen siendo los mismos que los explicados anteriormente.
Por último, destacar, como en los casos anteriores, que pesa a la mejor de las constantes ocultas, el comportamiento asintótico sigue siendo de nlogn en los tres casos.</p>

<h3>Conclusión acerca de la optimización:</h3>

<p>Como conclusión se puede sacar el hecho de que la optimización supone una mejora en tiempo y una modificación de las constantes ocultas, pero no supone un cambio en el comportamiento asintótico del algoritmo.</p>

<h2>Comparación de ejecuciones entre los componentes del grupo.</h2>

<p>En ésta última sección, vamos a comparar las ejecuciones realizadas en los 4 ordenadores de los componentes del grupo, y veamos las diferencias. Para ello, dentro de cada apartado, vamos a realizar una tabla de tres filas, teniendo cada una los datos para cierto <em>n</em> fijado de antemano.</p>

<h3>Características de los ordenadores</h3>

<p>Se proporcionan las características del ordenador de cada integrante del grupo.</p>

<ul>
<li><strong>Andrés :</strong> Toshiba - 8 GB de RAM - Intel&reg; Core&trade; i5-3210M CPU @ 2.50GHz</li>
<li><strong>Iván :</strong> HP - 4 GB de RAM - Intel&reg; Core&trade; i7-3630QM CPU @ 2.40GHz</li>
<li><strong>Antonio :</strong> Acer - 4 GB de RAM - Intel&reg; Core&trade; i5 CPU M 450 @ 2.40GHz</li>
<li><strong>Juan Luis :</strong> Olidata - 1 GB de RAM - Intel&reg; Atom&trade; CPU N450 @ 1.66GHz </li>
</ul>

<h3>Comparación: algoritmos cuadráticos</h3>

<p>En el caso de los cuadráticos, cogemos el método de inserción. </p>

<table><thead>
<tr>
<th>Tamaño del Vector</th>
<th>Andrés</th>
<th>Antonio</th>
<th>Iván</th>
<th>Juan Luis</th>
</tr>
</thead><tbody>
<tr>
<td>1000</td>
<td>0.001321</td>
<td>0.003619</td>
<td>0.001556</td>
<td>0.010846</td>
</tr>
<tr>
<td>13000</td>
<td>0.209278</td>
<td>0.34684</td>
<td>0.262103</td>
<td>1.26515</td>
</tr>
<tr>
<td>25000</td>
<td>0.762199</td>
<td>1.28187</td>
<td>0.978268</td>
<td>4.59284</td>
</tr>
</tbody></table>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesComparacion/insercion_comparacion.png}} \)</p>

<h3>Comparación: algoritmos cúbicos</h3>

<table><thead>
<tr>
<th>Nodos del grafo</th>
<th>Andrés</th>
<th>Antonio</th>
<th>Iván</th>
<th>Juan Luis</th>
</tr>
</thead><tbody>
<tr>
<td>32</td>
<td>0.000596</td>
<td>0.000961</td>
<td>0.000298</td>
<td>0.001617</td>
</tr>
<tr>
<td>416</td>
<td>0.460287</td>
<td>0.825125</td>
<td>0.586223</td>
<td>3.57139</td>
</tr>
<tr>
<td>800</td>
<td>3.25971</td>
<td>6.14008</td>
<td>4.15313</td>
<td>25.4081</td>
</tr>
</tbody></table>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesComparacion/floyd_comparacion.png}} \)</p>

<h3>Comparación: algoritmo de Fibonacci</h3>

<table><thead>
<tr>
<th>Índice</th>
<th>Andrés</th>
<th>Antonio</th>
<th>Iván</th>
<th>Juan Luis</th>
</tr>
</thead><tbody>
<tr>
<td>15</td>
<td>1.3e-05</td>
<td>1.5e-05</td>
<td>7e-06</td>
<td>3.2e-05</td>
</tr>
<tr>
<td>27</td>
<td>0.002394</td>
<td>0.004638</td>
<td>0.003859</td>
<td>0.020256</td>
</tr>
<tr>
<td>40</td>
<td>0.849934</td>
<td>1.21011</td>
<td>1.03951</td>
<td>4.43443</td>
</tr>
</tbody></table>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesComparacion/fibonacci_comparacion.png}} \)</p>

<h3>Comparación: algoritmo de las Torres de Hanoi</h3>

<table><thead>
<tr>
<th>Número de discos</th>
<th>Andrés</th>
<th>Antonio</th>
<th>Iván</th>
<th>Juan Luis</th>
</tr>
</thead><tbody>
<tr>
<td>5</td>
<td>1e-06</td>
<td>1e-06</td>
<td>1e-06</td>
<td>4e-06</td>
</tr>
<tr>
<td>17</td>
<td>0.002302</td>
<td>0.002542</td>
<td>0.00182</td>
<td>0.005348</td>
</tr>
<tr>
<td>30</td>
<td>7.63996</td>
<td>9.44513</td>
<td>9.81995</td>
<td>32.7569</td>
</tr>
</tbody></table>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesComparacion/hanoi_comparacion.png}} \)</p>

<h3>Comparación: algoritmos n logn</h3>

<p>El algoritmo que comparamos es el quicksort.</p>

<table><thead>
<tr>
<th>Tamaño del Vector</th>
<th>Andrés</th>
<th>Antonio</th>
<th>Iván</th>
<th>Juan Luis</th>
</tr>
</thead><tbody>
<tr>
<td>40000</td>
<td>0.006235</td>
<td>0.012287</td>
<td>0.007532</td>
<td>0.03168</td>
</tr>
<tr>
<td>520000</td>
<td>0.082585</td>
<td>0.118127</td>
<td>0.103365</td>
<td>0.272054</td>
</tr>
<tr>
<td>1000000</td>
<td>0.178312</td>
<td>0.229693</td>
<td>0.204994</td>
<td>0.583711</td>
</tr>
</tbody></table>

<p>\( \centerline{\includegraphics[height=7cm]{../Code/ImagenesComparacion/quicksort_comparacion.png}} \)</p>

<h3>Comentarios</h3>

<p>Tras ver los resultados de las distintas tablas, observamos que las prestaciones del ordenador de Andrés son superiores a los demás, y que la máquina utilizada por Juan Luis es muy lenta, que era lo que se esperaba previamente al experimento. Aun así, pese a la mejora de las prestaciones del ordenador de Andres, es claro que si el algorítmo es cúbico o exponencial, el tiempo de espera puede ser eterno para un <em>n</em> lo suficientemente grande, como es el caso de las torres de hanoi. Igualmente, un algorítmo muy rápido como el quicksort al compararlo en varias máquinas vemos que tampoco difiere mucho en cuanto a tiempos y que es mucho más importante este hecho que las prestaciones.</p>

</body>

</html>

